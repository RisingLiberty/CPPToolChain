// ============================================ 
//
// REX - BUILD SYSTEM
//
// Author: Nick De Breuck
// Twitter: @nick_debreuck
// 
// File: main.sharpmake.cs
// Copyright (c) Nick De Breuck 2022
//
// ============================================

using System.IO;
using Sharpmake;

public class Globals
{
  static readonly private string root_directory_name = "toolchain_test";
  static private string root;
  static private string source_root;
  
  static public string Root
  {
    get
    {
      return root;
    }
  }
  static public string SourceRoot
  {
    get
    {
      return source_root;
    }
  }

  static public void Init()
  {
    string current_directory = Directory.GetCurrentDirectory();
    
    while(Path.GetFileName(current_directory) != root_directory_name)
    {
      if (Directory.GetDirectoryRoot(current_directory) == current_directory)
      {
        throw new System.Exception("Failed to find root directory");
      }
      current_directory = Directory.GetParent(current_directory).FullName;
    }

    root = current_directory;
    source_root = Path.Combine(root, "source");
    System.Console.WriteLine($"Root path:{root}");
  }
}

// Represents the project that will be generated by Sharpmake and that contains
// the sample C++ code.
[Generate]
public class AppProject : Project
{
  public AppProject()
  {
    // The name of the project in Visual Studio. The default is the name of
    // the class, but you usually want to override that.
    Name = "App";

    // The directory that contains the source code we want to build is the
    // same as this one. This string essentially means "the directory of
    // the script you're reading right now."
    SourceRootPath = Path.Combine(Globals.SourceRoot, "app");

    // Specify the targets for which we want to generate a configuration for.
    AddTargets(new Target(
        // we want a target that builds for 64-bit Windows.
        Platform.win64,

        // we only care about Visual Studio 2019.
        DevEnv.vs2019,

        // of course, we want a debug and a release configuration.
        Optimization.Debug | Optimization.Release));
  }

  [Configure]
  public virtual void Configure(Configuration conf, Target target)
  {
    conf.Name = target.Optimization.ToString().ToLower();
    conf.ProjectPath = Path.Combine(Globals.Root, ".rex", "sharpmake", "intermediate");

    conf.Output = Configuration.OutputType.Exe;

    conf.Options.Add(Options.Vc.Compiler.CLanguageStandard.C17);
    conf.Options.Add(Options.Vc.Compiler.ConformanceMode.Enable);
    conf.Options.Add(Options.Vc.Compiler.CppLanguageStandard.CPP17);
    conf.Options.Add(Options.Vc.Compiler.Exceptions.Disable);
    conf.Options.Add(Options.Vc.Compiler.FavorSizeOrSpeed.FastCode);
    conf.Options.Add(Options.Vc.Compiler.FloatingPointExceptions.Disable);
    conf.Options.Add(Options.Vc.Compiler.FloatingPointModel.Fast);
    conf.Options.Add(Options.Vc.Compiler.ForceLoopScope.Enable);
    conf.Options.Add(Options.Vc.Compiler.FunctionLevelLinking.Enable);
    conf.Options.Add(Options.Vc.Compiler.MultiProcessorCompilation.Enable);
    conf.Options.Add(Options.Vc.Compiler.RemoveUnreferencedCodeData.Enable);
    conf.Options.Add(Options.Vc.Compiler.RTTI.Disable);
    conf.Options.Add(Options.Vc.Compiler.RuntimeChecks.Default);
    conf.Options.Add(Options.Vc.Compiler.StringPooling.Enable);
    conf.Options.Add(Options.Vc.Compiler.SupportJustMyCode.No);
    conf.Options.Add(Options.Vc.General.CharacterSet.MultiByte);
    conf.Options.Add(Options.Vc.General.PlatformToolset.v142);
    conf.Options.Add(Options.Vc.General.TreatWarningsAsErrors.Enable);
    conf.Options.Add(Options.Vc.General.WarningLevel.Level4);
    conf.Options.Add(Options.Vc.General.WindowsTargetPlatformVersion.v10_0_19041_0);
    conf.Options.Add(Options.Vc.Linker.SubSystem.Console);
    conf.Options.Add(Options.Vc.Linker.TreatLinkerWarningAsErrors.Enable);

    switch (target.Optimization)
    {
      case Optimization.Debug:
        conf.Options.Add(Options.Vc.Compiler.FunctionLevelLinking.Disable);
        conf.Options.Add(Options.Vc.Compiler.Inline.Disable);
        conf.Options.Add(Options.Vc.Compiler.Intrinsic.Disable);
        conf.Options.Add(Options.Vc.Compiler.OmitFramePointers.Disable);
        conf.Options.Add(Options.Vc.Compiler.OpenMP.Disable);
        conf.Options.Add(Options.Vc.Compiler.Optimization.Disable);
        conf.Options.Add(Options.Vc.Compiler.OptimizeGlobalData.Disable);
        conf.Options.Add(Options.Vc.Compiler.RuntimeLibrary.MultiThreadedDebug);
        conf.Options.Add(Options.Vc.General.WholeProgramOptimization.Disable);
        conf.Options.Add(Options.Vc.General.DebugInformation.ProgramDatabase);
        conf.Options.Add(Options.Vc.Linker.GenerateDebugInformation.Enable);
        conf.Options.Add(Options.Vc.Linker.GenerateFullProgramDatabaseFile.Enable);
        conf.Options.Add(Options.Vc.Linker.LinkTimeCodeGeneration.Default);
        break;
      case Optimization.Release:
        conf.Options.Add(Options.Vc.Compiler.FunctionLevelLinking.Enable);
        conf.Options.Add(Options.Vc.Compiler.Inline.AnySuitable);
        conf.Options.Add(Options.Vc.Compiler.Intrinsic.Enable);
        conf.Options.Add(Options.Vc.Compiler.OmitFramePointers.Enable);
        conf.Options.Add(Options.Vc.Compiler.OpenMP.Enable);
        conf.Options.Add(Options.Vc.Compiler.Optimization.FullOptimization);
        conf.Options.Add(Options.Vc.Compiler.OptimizeGlobalData.Enable);
        conf.Options.Add(Options.Vc.Compiler.RuntimeLibrary.MultiThreaded);
        conf.Options.Add(Options.Vc.General.WholeProgramOptimization.LinkTime);
        conf.Options.Add(Options.Vc.General.DebugInformation.Disable);
        conf.Options.Add(Options.Vc.Linker.GenerateDebugInformation.Disable);
        conf.Options.Add(Options.Vc.Linker.GenerateFullProgramDatabaseFile.Disable);
        conf.Options.Add(Options.Vc.Linker.LinkTimeCodeGeneration.UseFastLinkTimeCodeGeneration);
        break;
    }
  }

  // Represents the solution that will be generated and that will contain the
  // project with the sample code.
  [Generate]
  public class MainSolution : Solution
  {
    public MainSolution()
    {
      // The name of the solution.
      Name = "main_solution";

      // As with the project, define which target this solution builds for.
      // It's usually the same thing.
      AddTargets(new Target(
          Platform.win64,
          DevEnv.vs2019,
          Optimization.Debug | Optimization.Release));
    }

    // Configure for all 4 generated targets. Note that the type of the
    // configuration object is of type Solution.Configuration this time.
    // (Instead of Project.Configuration.)
    [Configure]
    public void Configure(Configuration conf, Target target)
    {
      // Puts the generated solution in the root folder.
      conf.SolutionPath = Globals.Root;

      // Adds the project described by BasicsProject into the solution.
      // Note that this is done in the configuration, so you can generate
      // solutions that contain different projects based on their target.
      //
      // You could, for example, exclude a project that only supports 64-bit
      // from the 32-bit targets.
      conf.AddProject<AppProject>(target);
    }
  }

  public static class Main
  {
    [Sharpmake.Main]
    public static void SharpmakeMain(Arguments arguments)
    {
      Globals.Init();

      // Initialize Visual Studio settings
      KitsRootPaths.SetUseKitsRootForDevEnv(DevEnv.vs2019, KitsRootEnum.KitsRoot10, Options.Vc.General.WindowsTargetPlatformVersion.v10_0_19041_0);

      // Tells Sharpmake to generate the solution described by MainSolution.
      arguments.Generate<MainSolution>();
    }
  }
}